{"ast":null,"code":"import axios from 'axios';\n\n// Use direct backend URL instead of proxy\nconst API_URL = 'http://localhost:8080';\n\n// Add basic request/response interceptors\naxios.interceptors.request.use(request => {\n  return request;\n}, error => {\n  return Promise.reject(error);\n});\naxios.interceptors.response.use(response => {\n  // Ensure both id and questionId are present in question objects\n  if (Array.isArray(response.data) && response.config.url.includes('/questions/')) {\n    response.data = response.data.map(item => {\n      // Handle case where questionId exists but id doesn't\n      if (item.questionId && !item.id) {\n        return {\n          ...item,\n          id: item.questionId\n        };\n      }\n      // Handle case where id exists but questionId doesn't\n      else if (item.id && !item.questionId) {\n        return {\n          ...item,\n          questionId: item.id\n        };\n      }\n      return item;\n    });\n  }\n  // Handle single question object\n  else if (response.data && !Array.isArray(response.data) && response.config.url.includes('/questions/')) {\n    const item = response.data;\n    if (item.questionId && !item.id) {\n      response.data = {\n        ...item,\n        id: item.questionId\n      };\n    } else if (item.id && !item.questionId) {\n      response.data = {\n        ...item,\n        questionId: item.id\n      };\n    }\n  }\n  return response;\n}, error => {\n  return Promise.reject(error);\n});\n\n// Create axios instance with CORS config\nconst apiClient = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// User related API calls - Matches UserController endpoints\nexport const userService = {\n  login: (username, password) => apiClient.post(`/users/login`, {\n    username,\n    password\n  }),\n  register: (username, email, password, phoneNumber) => apiClient.post(`/users/create`, {\n    username,\n    email,\n    password,\n    phoneNumber\n  }),\n  getUserById: id => apiClient.get(`/users/id/${id}`),\n  getUserByUsername: username => apiClient.get(`/users/username/${username}`),\n  updateUser: (id, data) => apiClient.put(`/users/${id}`, data),\n  getAllUsers: () => apiClient.get(`/users/all`)\n};\n\n// Question related API calls - Matches QuestionController endpoints\nexport const questionService = {\n  getAllQuestions: () => apiClient.get(`/questions/all`),\n  getQuestionById: id => {\n    // Validate id before sending to backend\n    if (id === undefined || id === null || id === 'undefined' || id === 'null') {\n      return Promise.reject(new Error('Invalid question ID'));\n    }\n    return apiClient.get(`/questions/find/${id}`);\n  },\n  getQuestionsByAuthor: authorId => {\n    // Validate authorId before sending to backend\n    if (authorId === undefined || authorId === null || authorId === 'undefined' || authorId === 'null') {\n      return Promise.reject(new Error('Invalid author ID'));\n    }\n    return apiClient.get(`/questions/author/${authorId}`);\n  },\n  getQuestionsByTag: tagName => apiClient.get(`/questions/tag/${tagName}`),\n  getQuestionsByStatus: status => apiClient.get(`/questions/status/${status}`),\n  searchQuestions: keyword => apiClient.get(`/questions/search?keyword=${keyword}`),\n  createQuestion: (authorId, title, text, image, tags) => {\n    // Validate inputs before sending to backend\n    if (!authorId || authorId === 'undefined') {\n      return Promise.reject(new Error('Author ID is required'));\n    }\n    if (!title || title.trim() === '') {\n      return Promise.reject(new Error('Title is required'));\n    }\n    if (!text || text.trim() === '') {\n      return Promise.reject(new Error('Question text is required'));\n    }\n    return apiClient.post(`/questions/create`, {\n      authorId,\n      title,\n      text,\n      image,\n      tags\n    });\n  },\n  updateQuestion: (id, data, userId) => {\n    // Validate inputs before sending to backend\n    if (!id || id === 'undefined') {\n      return Promise.reject(new Error('Question ID is required'));\n    }\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    return apiClient.put(`/questions/update/${id}?userId=${userId}`, data);\n  },\n  acceptAnswer: (questionId, answerId) => {\n    // Validate inputs before sending to backend\n    if (!questionId || questionId === 'undefined') {\n      return Promise.reject(new Error('Question ID is required'));\n    }\n    if (!answerId || answerId === 'undefined') {\n      return Promise.reject(new Error('Answer ID is required'));\n    }\n    return apiClient.put(`/questions/${questionId}/accept/${answerId}`);\n  },\n  deleteQuestion: (id, userId) => {\n    // Validate inputs before sending to backend\n    if (!id || id === 'undefined') {\n      return Promise.reject(new Error('Question ID is required'));\n    }\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    return apiClient.delete(`/questions/delete/${id}?userId=${userId}`);\n  }\n};\n\n// Answer related API calls - Matches AnswerController endpoints\nexport const answerService = {\n  getAllAnswers: () => apiClient.get(`/answers/all`),\n  getAnswerById: id => {\n    // Validate id before sending to backend\n    if (id === undefined || id === null || id === 'undefined' || id === 'null') {\n      return Promise.reject(new Error('Invalid answer ID'));\n    }\n    return apiClient.get(`/answers/id/${id}`);\n  },\n  getAnswersByQuestion: questionId => {\n    // Validate questionId before sending to backend\n    if (questionId === undefined || questionId === null || questionId === 'undefined' || questionId === 'null') {\n      return Promise.reject(new Error('Invalid question ID'));\n    }\n    return apiClient.get(`/answers/question/${questionId}`);\n  },\n  getAnswersByAuthor: authorId => {\n    // Validate authorId before sending to backend\n    if (authorId === undefined || authorId === null || authorId === 'undefined' || authorId === 'null') {\n      return Promise.reject(new Error('Invalid author ID'));\n    }\n    return apiClient.get(`/answers/author/${authorId}`);\n  },\n  debugAnswer: (authorId, questionId, text, code) => {\n    // Validate inputs\n    if (!questionId || questionId === 'undefined') {\n      return Promise.reject(new Error(\"Invalid question ID\"));\n    }\n    if (!authorId || authorId === 'undefined') {\n      return Promise.reject(new Error(\"Invalid author ID\"));\n    }\n    const payload = {\n      id: String(questionId),\n      authorId: String(authorId),\n      text: text || \"Test answer\",\n      image: code || \"\"\n    };\n    console.log(\"Debug answer with payload:\", payload);\n    return apiClient.post(`/answers/debug`, payload);\n  },\n  createAnswer: (authorId, questionId, text, code) => {\n    // Validate inputs with stronger checks\n    if (questionId === undefined || questionId === null || questionId === 'undefined' || questionId === 'null') {\n      return Promise.reject(new Error(\"Invalid question ID\"));\n    }\n    if (authorId === undefined || authorId === null || authorId === 'undefined' || authorId === 'null') {\n      return Promise.reject(new Error(\"Invalid author ID\"));\n    }\n    if (!text || text.trim() === '') {\n      return Promise.reject(new Error(\"Answer text cannot be empty\"));\n    }\n    try {\n      const numQuestionId = Number(questionId);\n      const numAuthorId = Number(authorId);\n      if (isNaN(numQuestionId) || isNaN(numAuthorId)) {\n        return Promise.reject(new Error(\"Invalid ID format\"));\n      }\n\n      // Use the direct-create endpoint with query parameters\n      return apiClient.post(`/answers/direct-create`, null, {\n        params: {\n          questionId: numQuestionId,\n          authorId: numAuthorId,\n          text: text.trim(),\n          image: code || \"\"\n        }\n      });\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  },\n  updateAnswer: (id, data, userId) => {\n    // Validate inputs before sending to backend\n    if (!id || id === 'undefined') {\n      return Promise.reject(new Error('Answer ID is required'));\n    }\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    return apiClient.put(`/answers/update/${id}?userId=${userId}`, data);\n  },\n  deleteAnswer: (id, userId) => {\n    // Validate inputs before sending to backend\n    if (!id || id === 'undefined') {\n      return Promise.reject(new Error('Answer ID is required'));\n    }\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    return apiClient.delete(`/answers/delete/${id}?userId=${userId}`);\n  }\n};\n\n// Vote related API calls - Matches VoteController endpoints\nexport const voteService = {\n  getAllVotes: () => apiClient.get(`/votes/all`),\n  getVoteById: id => {\n    // Validate id before sending to backend\n    if (id === undefined || id === null || id === 'undefined' || id === 'null') {\n      return Promise.reject(new Error('Invalid vote ID'));\n    }\n    return apiClient.get(`/votes/id/${id}`);\n  },\n  getVotesByUser: userId => {\n    // Validate userId before sending to backend\n    if (userId === undefined || userId === null || userId === 'undefined' || userId === 'null') {\n      return Promise.reject(new Error('Invalid user ID'));\n    }\n    return apiClient.get(`/votes/user/${userId}`);\n  },\n  voteQuestion: (userId, questionId, voteType) => {\n    // Validate inputs before sending to backend\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    if (!questionId || questionId === 'undefined') {\n      return Promise.reject(new Error('Question ID is required'));\n    }\n    if (!voteType) {\n      return Promise.reject(new Error('Vote type is required'));\n    }\n    return apiClient.post(`/votes/question`, {\n      userId,\n      questionId,\n      voteType\n    });\n  },\n  voteAnswer: (userId, answerId, voteType) => {\n    // Validate inputs before sending to backend\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    if (!answerId || answerId === 'undefined') {\n      return Promise.reject(new Error('Answer ID is required'));\n    }\n    if (!voteType) {\n      return Promise.reject(new Error('Vote type is required'));\n    }\n    return apiClient.post(`/votes/answer`, {\n      userId,\n      answerId,\n      voteType\n    });\n  },\n  deleteVote: id => {\n    // Validate id before sending to backend\n    if (!id || id === 'undefined') {\n      return Promise.reject(new Error('Vote ID is required'));\n    }\n    return apiClient.delete(`/votes/delete/${id}`);\n  }\n};\n\n// Tag related API calls - Matches TagController endpoints (note the URL is /tag not /tags)\nexport const tagService = {\n  getAllTags: () => apiClient.get(`/tag/all`),\n  getTagById: id => apiClient.get(`/tag/id/${id}`),\n  getTagByName: name => apiClient.get(`/tag/name/${name}`),\n  createTag: name => apiClient.post(`/tag/create`, {\n    name\n  }),\n  updateTag: (id, name) => apiClient.put(`/tag/update/${id}`, {\n    name\n  }),\n  deleteTag: id => apiClient.delete(`/tag/delete/${id}`)\n};","map":{"version":3,"names":["axios","API_URL","interceptors","request","use","error","Promise","reject","response","Array","isArray","data","config","url","includes","map","item","questionId","id","apiClient","create","baseURL","headers","userService","login","username","password","post","register","email","phoneNumber","getUserById","get","getUserByUsername","updateUser","put","getAllUsers","questionService","getAllQuestions","getQuestionById","undefined","Error","getQuestionsByAuthor","authorId","getQuestionsByTag","tagName","getQuestionsByStatus","status","searchQuestions","keyword","createQuestion","title","text","image","tags","trim","updateQuestion","userId","acceptAnswer","answerId","deleteQuestion","delete","answerService","getAllAnswers","getAnswerById","getAnswersByQuestion","getAnswersByAuthor","debugAnswer","code","payload","String","console","log","createAnswer","numQuestionId","Number","numAuthorId","isNaN","params","err","updateAnswer","deleteAnswer","voteService","getAllVotes","getVoteById","getVotesByUser","voteQuestion","voteType","voteAnswer","deleteVote","tagService","getAllTags","getTagById","getTagByName","name","createTag","updateTag","deleteTag"],"sources":["/Users/danielrad/Desktop/QZ/Coding/Facultate/PS/StackUnderflow/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\n\n// Use direct backend URL instead of proxy\nconst API_URL = 'http://localhost:8080';\n\n// Add basic request/response interceptors\naxios.interceptors.request.use(request => {\n  return request;\n}, error => {\n  return Promise.reject(error);\n});\n\naxios.interceptors.response.use(response => {\n  // Ensure both id and questionId are present in question objects\n  if (Array.isArray(response.data) && response.config.url.includes('/questions/')) {\n    response.data = response.data.map(item => {\n      // Handle case where questionId exists but id doesn't\n      if (item.questionId && !item.id) {\n        return { ...item, id: item.questionId };\n      } \n      // Handle case where id exists but questionId doesn't\n      else if (item.id && !item.questionId) {\n        return { ...item, questionId: item.id };\n      }\n      return item;\n    });\n  }\n  // Handle single question object\n  else if (response.data && !Array.isArray(response.data) && response.config.url.includes('/questions/')) {\n    const item = response.data;\n    if (item.questionId && !item.id) {\n      response.data = { ...item, id: item.questionId };\n    } else if (item.id && !item.questionId) {\n      response.data = { ...item, questionId: item.id };\n    }\n  }\n  \n  return response;\n}, error => {\n  return Promise.reject(error);\n});\n\n// Create axios instance with CORS config\nconst apiClient = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// User related API calls - Matches UserController endpoints\nexport const userService = {\n  login: (username, password) => apiClient.post(`/users/login`, { username, password }),\n  register: (username, email, password, phoneNumber) => apiClient.post(`/users/create`, { username, email, password, phoneNumber }),\n  getUserById: (id) => apiClient.get(`/users/id/${id}`),\n  getUserByUsername: (username) => apiClient.get(`/users/username/${username}`),\n  updateUser: (id, data) => apiClient.put(`/users/${id}`, data),\n  getAllUsers: () => apiClient.get(`/users/all`)\n};\n\n// Question related API calls - Matches QuestionController endpoints\nexport const questionService = {\n  getAllQuestions: () => apiClient.get(`/questions/all`),\n  getQuestionById: (id) => {\n    // Validate id before sending to backend\n    if (id === undefined || id === null || id === 'undefined' || id === 'null') {\n      return Promise.reject(new Error('Invalid question ID'));\n    }\n    return apiClient.get(`/questions/find/${id}`);\n  },\n  getQuestionsByAuthor: (authorId) => {\n    // Validate authorId before sending to backend\n    if (authorId === undefined || authorId === null || authorId === 'undefined' || authorId === 'null') {\n      return Promise.reject(new Error('Invalid author ID'));\n    }\n    return apiClient.get(`/questions/author/${authorId}`);\n  },\n  getQuestionsByTag: (tagName) => apiClient.get(`/questions/tag/${tagName}`),\n  getQuestionsByStatus: (status) => apiClient.get(`/questions/status/${status}`),\n  searchQuestions: (keyword) => apiClient.get(`/questions/search?keyword=${keyword}`),\n  createQuestion: (authorId, title, text, image, tags) => {\n    // Validate inputs before sending to backend\n    if (!authorId || authorId === 'undefined') {\n      return Promise.reject(new Error('Author ID is required'));\n    }\n    if (!title || title.trim() === '') {\n      return Promise.reject(new Error('Title is required'));\n    }\n    if (!text || text.trim() === '') {\n      return Promise.reject(new Error('Question text is required'));\n    }\n    \n    return apiClient.post(`/questions/create`, { authorId, title, text, image, tags });\n  },\n  updateQuestion: (id, data, userId) => {\n    // Validate inputs before sending to backend\n    if (!id || id === 'undefined') {\n      return Promise.reject(new Error('Question ID is required'));\n    }\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    \n    return apiClient.put(`/questions/update/${id}?userId=${userId}`, data);\n  },\n  acceptAnswer: (questionId, answerId) => {\n    // Validate inputs before sending to backend\n    if (!questionId || questionId === 'undefined') {\n      return Promise.reject(new Error('Question ID is required'));\n    }\n    if (!answerId || answerId === 'undefined') {\n      return Promise.reject(new Error('Answer ID is required'));\n    }\n    \n    return apiClient.put(`/questions/${questionId}/accept/${answerId}`);\n  },\n  deleteQuestion: (id, userId) => {\n    // Validate inputs before sending to backend\n    if (!id || id === 'undefined') {\n      return Promise.reject(new Error('Question ID is required'));\n    }\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    \n    return apiClient.delete(`/questions/delete/${id}?userId=${userId}`);\n  }\n};\n\n// Answer related API calls - Matches AnswerController endpoints\nexport const answerService = {\n  getAllAnswers: () => apiClient.get(`/answers/all`),\n  getAnswerById: (id) => {\n    // Validate id before sending to backend\n    if (id === undefined || id === null || id === 'undefined' || id === 'null') {\n      return Promise.reject(new Error('Invalid answer ID'));\n    }\n    return apiClient.get(`/answers/id/${id}`);\n  },\n  getAnswersByQuestion: (questionId) => {\n    // Validate questionId before sending to backend\n    if (questionId === undefined || questionId === null || questionId === 'undefined' || questionId === 'null') {\n      return Promise.reject(new Error('Invalid question ID'));\n    }\n    return apiClient.get(`/answers/question/${questionId}`);\n  },\n  getAnswersByAuthor: (authorId) => {\n    // Validate authorId before sending to backend\n    if (authorId === undefined || authorId === null || authorId === 'undefined' || authorId === 'null') {\n      return Promise.reject(new Error('Invalid author ID'));\n    }\n    return apiClient.get(`/answers/author/${authorId}`);\n  },\n  debugAnswer: (authorId, questionId, text, code) => {\n    // Validate inputs\n    if (!questionId || questionId === 'undefined') {\n      return Promise.reject(new Error(\"Invalid question ID\"));\n    }\n    \n    if (!authorId || authorId === 'undefined') {\n      return Promise.reject(new Error(\"Invalid author ID\"));\n    }\n    \n    const payload = { \n      id: String(questionId), \n      authorId: String(authorId), \n      text: text || \"Test answer\", \n      image: code || \"\" \n    };\n    \n    console.log(\"Debug answer with payload:\", payload);\n    return apiClient.post(`/answers/debug`, payload);\n  },\n  createAnswer: (authorId, questionId, text, code) => {\n    // Validate inputs with stronger checks\n    if (questionId === undefined || questionId === null || questionId === 'undefined' || questionId === 'null') {\n      return Promise.reject(new Error(\"Invalid question ID\"));\n    }\n    \n    if (authorId === undefined || authorId === null || authorId === 'undefined' || authorId === 'null') {\n      return Promise.reject(new Error(\"Invalid author ID\"));\n    }\n    \n    if (!text || text.trim() === '') {\n      return Promise.reject(new Error(\"Answer text cannot be empty\"));\n    }\n    \n    try {\n      const numQuestionId = Number(questionId);\n      const numAuthorId = Number(authorId);\n      \n      if (isNaN(numQuestionId) || isNaN(numAuthorId)) {\n        return Promise.reject(new Error(\"Invalid ID format\"));\n      }\n      \n      // Use the direct-create endpoint with query parameters\n      return apiClient.post(`/answers/direct-create`, null, { \n        params: {\n          questionId: numQuestionId,\n          authorId: numAuthorId,\n          text: text.trim(),\n          image: code || \"\"\n        }\n      });\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  },\n  updateAnswer: (id, data, userId) => {\n    // Validate inputs before sending to backend\n    if (!id || id === 'undefined') {\n      return Promise.reject(new Error('Answer ID is required'));\n    }\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    \n    return apiClient.put(`/answers/update/${id}?userId=${userId}`, data);\n  },\n  deleteAnswer: (id, userId) => {\n    // Validate inputs before sending to backend\n    if (!id || id === 'undefined') {\n      return Promise.reject(new Error('Answer ID is required'));\n    }\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    \n    return apiClient.delete(`/answers/delete/${id}?userId=${userId}`);\n  }\n};\n\n// Vote related API calls - Matches VoteController endpoints\nexport const voteService = {\n  getAllVotes: () => apiClient.get(`/votes/all`),\n  getVoteById: (id) => {\n    // Validate id before sending to backend\n    if (id === undefined || id === null || id === 'undefined' || id === 'null') {\n      return Promise.reject(new Error('Invalid vote ID'));\n    }\n    return apiClient.get(`/votes/id/${id}`);\n  },\n  getVotesByUser: (userId) => {\n    // Validate userId before sending to backend\n    if (userId === undefined || userId === null || userId === 'undefined' || userId === 'null') {\n      return Promise.reject(new Error('Invalid user ID'));\n    }\n    return apiClient.get(`/votes/user/${userId}`);\n  },\n  voteQuestion: (userId, questionId, voteType) => {\n    // Validate inputs before sending to backend\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    if (!questionId || questionId === 'undefined') {\n      return Promise.reject(new Error('Question ID is required'));\n    }\n    if (!voteType) {\n      return Promise.reject(new Error('Vote type is required'));\n    }\n    \n    return apiClient.post(`/votes/question`, { userId, questionId, voteType });\n  },\n  voteAnswer: (userId, answerId, voteType) => {\n    // Validate inputs before sending to backend\n    if (!userId || userId === 'undefined') {\n      return Promise.reject(new Error('User ID is required'));\n    }\n    if (!answerId || answerId === 'undefined') {\n      return Promise.reject(new Error('Answer ID is required'));\n    }\n    if (!voteType) {\n      return Promise.reject(new Error('Vote type is required'));\n    }\n    \n    return apiClient.post(`/votes/answer`, { userId, answerId, voteType });\n  },\n  deleteVote: (id) => {\n    // Validate id before sending to backend\n    if (!id || id === 'undefined') {\n      return Promise.reject(new Error('Vote ID is required'));\n    }\n    return apiClient.delete(`/votes/delete/${id}`);\n  }\n};\n\n// Tag related API calls - Matches TagController endpoints (note the URL is /tag not /tags)\nexport const tagService = {\n  getAllTags: () => apiClient.get(`/tag/all`),\n  getTagById: (id) => apiClient.get(`/tag/id/${id}`),\n  getTagByName: (name) => apiClient.get(`/tag/name/${name}`),\n  createTag: (name) => apiClient.post(`/tag/create`, { name }),\n  updateTag: (id, name) => apiClient.put(`/tag/update/${id}`, { name }),\n  deleteTag: (id) => apiClient.delete(`/tag/delete/${id}`)\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}